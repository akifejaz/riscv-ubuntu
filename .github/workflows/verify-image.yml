name: RISC-V QEMU Ubuntu Test

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  test-riscv-qemu:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    env:
      CONTAINER_NAME: riscv-test
      LOG_DIR: ${{ github.workspace }}/var/log/qemu
      WORK_DIR: ${{ github.workspace }}/workspace
      CONSOLE_LOG: ${{ github.workspace }}/var/log/qemu/console.log
      GUEST_FIFO: /var/log/qemu/guest.in
      STREAM_TIMEOUT_SECONDS: "180"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Prepare directories & permissions
        run: |
          set -euo pipefail
          mkdir -p "${LOG_DIR}" "${WORK_DIR}"
          chmod 755 "${LOG_DIR}" "${WORK_DIR}"
          # Ensure the interactive wrapper is executable
          chmod +x scripts/shell.sh

      - name: Pull RISC-V QEMU Ubuntu image
        run: |
          set -euo pipefail
          docker pull cloudv10x/riscv-qemu-ubuntu:latest
          docker images cloudv10x/riscv-qemu-ubuntu:latest

      - name: Start RISC-V QEMU container (headless)
        id: start-container
        run: |
          set -euo pipefail
          CONTAINER_ID=$(docker run -d \
            --name "${CONTAINER_NAME}" \
            --privileged \
            -v "${WORK_DIR}":/workspace \
            -v "${LOG_DIR}":/var/log/qemu \
            -e AUTO_ATTACH=0 \
            cloudv10x/riscv-qemu-ubuntu:latest)
          echo "container_id=$CONTAINER_ID" >> "$GITHUB_OUTPUT"
          docker ps --filter "name=${CONTAINER_NAME}"

      - name: Wait for QEMU boot completion
        timeout-minutes: 15
        run: |
          set -euo pipefail
          echo "Waiting for QEMU to boot completely..."

          READY_PATTERNS=(
            "System is ready for headless operation"
            "RISC-V Ubuntu image is ready"
          )

          # Up to 15 minutes (180 * 5s)
          for i in $(seq 1 180); do
            if ! docker ps --format '{{.Names}}' | grep -qx "${CONTAINER_NAME}"; then
              echo "ERROR: Container exited early!"
              docker logs "${CONTAINER_NAME}" || true
              exit 1
            fi

            LOGS="$(docker logs "${CONTAINER_NAME}" 2>&1 | tail -n 500 || true)"
            for pat in "${READY_PATTERNS[@]}"; do
              if echo "${LOGS}" | grep -q "${pat}"; then
                echo "✓ Boot completed: '${pat}'"
                FOUND=1
                break
              fi
            done
            [ "${FOUND:-0}" = "1" ] && break

            if [ "$i" -eq 180 ]; then
              echo "ERROR: Boot timeout - system not ready after 15 minutes"
              echo "=== Container Logs (tail) ==="
              echo "${LOGS}"
              exit 1
            fi

            if [ $((i % 10)) -eq 0 ]; then
              echo "Still waiting... ($i/180 checks, ~$((i*5)) seconds elapsed)"
            fi
            sleep 5
          done

          echo "=== Boot Summary (last 40 lines) ==="
          docker logs "${CONTAINER_NAME}" --tail 40 2>&1 || true

      - name: Verify headless interface
        run: |
          set -euo pipefail
          echo "Verifying headless interface components..."

          # Must have PTY path
          docker exec "${CONTAINER_NAME}" test -f /var/log/qemu/pty.path || { echo "ERROR: PTY path file not found"; exit 1; }
          PTY_PATH="$(docker exec "${CONTAINER_NAME}" cat /var/log/qemu/pty.path)"
          echo "Guest PTY: ${PTY_PATH}"
          echo "GUEST_PTY=${PTY_PATH}" >> $GITHUB_ENV

          # Ensure console.log exists (host-mounted)
          docker exec "${CONTAINER_NAME}" test -f /var/log/qemu/console.log || { echo "ERROR: console.log missing"; exit 1; }

          # Ensure FIFO exists; if missing, create it
          if ! docker exec "${CONTAINER_NAME}" test -p /var/log/qemu/guest.in; then
            echo "guest.in FIFO missing — creating..."
            docker exec "${CONTAINER_NAME}" bash -lc '
              set -euo pipefail
              mkdir -p /var/log/qemu
              [ -p /var/log/qemu/guest.in ] || mkfifo /var/log/qemu/guest.in
              chmod 666 /var/log/qemu/guest.in || true
            '
            echo "✓ FIFO created"
          else
            echo "✓ guest.in FIFO present"
          fi

          # List QEMU directory contents
          echo "=== QEMU directory contents ==="
          docker exec "${CONTAINER_NAME}" ls -la /var/log/qemu/

          # Start FIFO bridge if not running
          echo "=== Starting FIFO -> PTY bridge ==="
          docker exec "${CONTAINER_NAME}" bash -lc '
            set -euo pipefail
            PTY="$(cat /var/log/qemu/pty.path)"
            
            # Kill any existing bridge
            pkill -f "cat /var/log/qemu/guest.in" 2>/dev/null || true
            sleep 0.5
            
            # Start bridge in background
            nohup bash -c "
              exec </dev/null >/var/log/qemu/guest-bridge.log 2>&1
              echo \"Bridge started at \$(date)\"
              echo \"Reading from /var/log/qemu/guest.in\"
              echo \"Writing to ${PTY}\"
              stdbuf -i0 -o0 -e0 cat /var/log/qemu/guest.in > \"${PTY}\"
            " >/dev/null 2>&1 &
            
            BRIDGE_PID=$!
            echo "Bridge process started with PID: ${BRIDGE_PID}"
            sleep 1
            
            # Verify bridge is running
            if ps -p ${BRIDGE_PID} >/dev/null 2>&1; then
              echo "✓ Bridge process is running"
            else
              echo "WARNING: Bridge process may have exited"
              cat /var/log/qemu/guest-bridge.log 2>/dev/null || true
            fi
          '
          
          echo "=== Bridge log ==="
          docker exec "${CONTAINER_NAME}" cat /var/log/qemu/guest-bridge.log 2>/dev/null || echo "(no bridge log yet)"

      - name: Test command execution with marker-based streaming
        timeout-minutes: 5
        run: |
          set -euo pipefail
          
          # Define helper functions for command execution
          send_byte_to_guest() {
            local -i code="$1"
            docker exec "${CONTAINER_NAME}" bash -lc "printf '\\x%02x' ${code} > '${GUEST_FIFO}'"
          }

          send_to_guest() {
            local text="$1"
            echo "DEBUG: Sending to guest: ${text:0:80}..." >&2
            docker exec "${CONTAINER_NAME}" bash -lc "printf '%s\n' \"${text}\" > '${GUEST_FIFO}'"
            echo "DEBUG: Send completed" >&2
          }

          run_cmd_stream() {
            local cmd="$1"
            local timeout="${2:-60}"
            
            echo ">>> Running command: ${cmd}"
            
            # Unique markers per command
            local uid
            uid="$(date +%s%N)-$RANDOM"
            local START="__HOST_START__${uid}__"
            local END="__HOST_END__${uid}__"
            
            # Compose compound command with start/end markers
            local inject="{ echo ${START}; { ${cmd}; rc=\$?; }; printf '${END} EXIT=%d\n' \"\${rc}\"; } 2>&1"
            
            echo "DEBUG: Starting tail process..." >&2
            
            # Start tail and filter between markers with timeout
            timeout ${timeout}s stdbuf -oL -eL tail -n0 -F "${CONSOLE_LOG}" 2>/dev/null \
              | awk -v start="${START}" -v end="${END}" '
                  BEGIN { started=0 }
                  {
                    if (!started) {
                      if (index($0, start)) { 
                        started=1
                        print "[DEBUG] Found START marker" > "/dev/stderr"
                        next 
                      }
                      next
                    } else {
                      if (index($0, end)) {
                        print "[DEBUG] Found END marker" > "/dev/stderr"
                        exitidx = index($0, "EXIT=");
                        if (exitidx > 0) {
                          code = substr($0, exitidx+5);
                          printf("[exit %s]\n", code);
                        }
                        exit 0
                      }
                      print
                    }
                  }
                ' &
            local awk_pid=$!
            
            echo "DEBUG: Tail/awk PID: ${awk_pid}" >&2
            
            # Handle Ctrl-C
            trap 'send_byte_to_guest 3 >/dev/null 2>&1 || true; kill -TERM '"$awk_pid"' >/dev/null 2>&1 || true' INT
            
            # Small delay to ensure tail is ready
            sleep 1
            
            # Inject the compound command
            send_to_guest "${inject}"
            
            echo "DEBUG: Waiting for command completion..." >&2
            
            # Wait for awk to finish with timeout
            if wait "${awk_pid}" 2>/dev/null; then
              echo "DEBUG: Command completed successfully" >&2
            else
              local exit_code=$?
              echo "WARNING: Wait exited with code ${exit_code}" >&2
            fi
            
            trap - INT
            echo ""
          }

          # First, verify bridge is working with a simple test
          echo "=== Testing FIFO/PTY bridge ==="
          PROBE="__BRIDGE_TEST__$(date +%s)"
          echo "Sending probe: ${PROBE}"
          
          docker exec "${CONTAINER_NAME}" bash -lc "echo 'echo ${PROBE}' > '${GUEST_FIFO}'"
          
          sleep 2
          
          if docker exec "${CONTAINER_NAME}" grep -q "${PROBE}" /var/log/qemu/console.log; then
            echo "✓ Bridge is working - probe found in console.log"
          else
            echo "✗ Bridge test failed - probe not found"
            echo "=== Console log (last 50 lines) ==="
            docker exec "${CONTAINER_NAME}" tail -n 50 /var/log/qemu/console.log
            echo "=== Bridge log ==="
            docker exec "${CONTAINER_NAME}" cat /var/log/qemu/guest-bridge.log 2>/dev/null || echo "(no log)"
            exit 1
          fi

          # Test simple command
          echo ""
          echo "=== Testing basic command execution ==="
          run_cmd_stream "echo 'Hello from QEMU guest'" 30
          
          echo "=== Testing system info command ==="
          run_cmd_stream "uname -a" 30

      - name: Run sanity suite with marker-based streaming
        run: |
          set -euo pipefail

          # Define helper functions
          send_byte_to_guest() {
            local -i code="$1"
            docker exec "${CONTAINER_NAME}" bash -lc "printf '\\x%02x' ${code} > '${GUEST_FIFO}'"
          }

          send_to_guest() {
            local text="$1"
            docker exec "${CONTAINER_NAME}" bash -lc "printf '%s\n' \"${text}\" > '${GUEST_FIFO}'"
          }

          run_cmd_stream() {
            local cmd="$1"
            
            local uid
            uid="$(date +%s%N)-$RANDOM"
            local START="__HOST_START__${uid}__"
            local END="__HOST_END__${uid}__"
            
            local inject="{ echo ${START}; { ${cmd}; rc=\$?; }; printf '${END} EXIT=%d\n' \"\${rc}\"; } 2>&1"
            
            stdbuf -oL -eL tail -n0 -F "${CONSOLE_LOG}" 2>/dev/null \
              | awk -v start="${START}" -v end="${END}" '
                  BEGIN { started=0 }
                  {
                    if (!started) {
                      if (index($0, start)) { started=1; next }
                      next
                    } else {
                      if (index($0, end)) {
                        exitidx = index($0, "EXIT=");
                        if (exitidx > 0) {
                          code = substr($0, exitidx+5);
                          printf("[exit %s]\n", code);
                        }
                        exit 0
                      }
                      print
                    }
                  }
                ' &
            local awk_pid=$!
            
            trap 'send_byte_to_guest 3 >/dev/null 2>&1 || true; kill -TERM '"$awk_pid"' >/dev/null 2>&1 || true' INT
            
            sleep 0.3
            send_to_guest "${inject}"
            
            wait "${awk_pid}" || true
            trap - INT
          }

          # Run test commands
          echo "=== System Information Tests ==="
          
          run_cmd_stream "uname -a"
          run_cmd_stream "whoami"
          run_cmd_stream "pwd"
          
          echo ""
          echo "=== System Configuration ==="
          run_cmd_stream "cat /etc/os-release | head -3"
          run_cmd_stream "lscpu | head -10"
          run_cmd_stream "free -h"
          run_cmd_stream "df -h /"
          
          echo ""
          echo "=== Workspace Tests ==="
          run_cmd_stream "ls -la /workspace"
          run_cmd_stream "echo 'GitHub Actions Test - $(date)' | tee /workspace/test_output.txt"
          run_cmd_stream "cat /workspace/test_output.txt"
          
          echo ""
          echo "✓ All sanity tests completed"

      - name: Verify test results on host
        run: |
          set -euo pipefail
          echo "=== Verifying Test Results ==="
          if [ -f "${WORK_DIR}/test_output.txt" ]; then
            echo "✓ Workspace file successfully created"
            echo "Contents:"
            cat "${WORK_DIR}/test_output.txt"
          else
            echo "✗ ERROR: Workspace test file not found"
            exit 1
          fi

      - name: Display final console output
        if: always()
        run: |
          echo "=== Final Console Output (last 120 lines) ==="
          docker exec "${CONTAINER_NAME}" tail -n 120 /var/log/qemu/console.log 2>/dev/null || echo "Console log not accessible"

      - name: Logs and diagnostics
        if: always()
        run: |
          echo "=== Container Status ==="
          docker ps -a --filter "name=${CONTAINER_NAME}"

          echo ""
          echo "=== Mounted Workspace ==="
          ls -la "${WORK_DIR}" || echo "Workspace not found"

          echo ""
          echo "=== Mounted Log Directory ==="
          ls -la "${LOG_DIR}" || echo "Log directory not found"

          echo ""
          echo "=== Container Boot Log (last 60 lines) ==="
          docker logs --tail 60 "${CONTAINER_NAME}" 2>&1 || echo "Could not get container logs"

          echo ""
          echo "=== QEMU Boot Log (last 40 lines) ==="
          docker exec "${CONTAINER_NAME}" tail -n 40 /var/log/qemu/qemu.boot.log 2>/dev/null || echo "Boot log not accessible"

      - name: Upload logs and artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: riscv-qemu-logs
          path: |
            ${{ github.workspace }}/var/log/qemu/
            ${{ github.workspace }}/workspace/
          retention-days: 7

      - name: Cleanup
        if: always()
        run: |
          docker stop "${CONTAINER_NAME}" 2>/dev/null || true
          docker rm "${CONTAINER_NAME}" 2>/dev/null || true