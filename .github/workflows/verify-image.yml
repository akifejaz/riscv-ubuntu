name: RISC-V QEMU Ubuntu Test

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  test-riscv-qemu:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    env:
      CONTAINER_NAME: riscv-test
      LOG_DIR: ${{ github.workspace }}/var/log/qemu
      WORK_DIR: ${{ github.workspace }}/workspace
      # Optional: tighten/relax shell streaming timeout (seconds)
      STREAM_TIMEOUT_SECONDS: "180"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Prepare directories & permissions
        run: |
          set -euo pipefail
          mkdir -p "${LOG_DIR}" "${WORK_DIR}"
          chmod 755 "${LOG_DIR}" "${WORK_DIR}"
          # Ensure the interactive wrapper is executable
          chmod +x scripts/shell.sh

      - name: Pull RISC-V QEMU Ubuntu image
        run: |
          set -euo pipefail
          docker pull cloudv10x/riscv-qemu-ubuntu:latest
          docker images cloudv10x/riscv-qemu-ubuntu:latest

      - name: Start RISC-V QEMU container (headless)
        id: start-container
        run: |
          set -euo pipefail
          CONTAINER_ID=$(docker run -d \
            --name "${CONTAINER_NAME}" \
            --privileged \
            -v "${WORK_DIR}":/workspace \
            -v "${LOG_DIR}":/var/log/qemu \
            -e AUTO_ATTACH=0 \
            cloudv10x/riscv-qemu-ubuntu:latest)
          echo "container_id=$CONTAINER_ID" >> "$GITHUB_OUTPUT"
          docker ps --filter "name=${CONTAINER_NAME}"

      - name: Wait for QEMU boot completion
        timeout-minutes: 15
        run: |
          set -euo pipefail
          echo "Waiting for QEMU to boot completely..."

          READY_PATTERNS=(
            "System is ready for headless operation"
            "RISC-V Ubuntu image is ready"
          )

          # Up to 15 minutes (180 * 5s)
          for i in $(seq 1 180); do
            if ! docker ps --format '{{.Names}}' | grep -qx "${CONTAINER_NAME}"; then
              echo "ERROR: Container exited early!"
              docker logs "${CONTAINER_NAME}" || true
              exit 1
            fi

            LOGS="$(docker logs "${CONTAINER_NAME}" 2>&1 | tail -n 500 || true)"
            for pat in "${READY_PATTERNS[@]}"; do
              if echo "${LOGS}" | grep -q "${pat}"; then
                echo "✓ Boot completed: '${pat}'"
                FOUND=1
                break
              fi
            done
            [ "${FOUND:-0}" = "1" ] && break

            if [ "$i" -eq 180 ]; then
              echo "ERROR: Boot timeout - system not ready after 15 minutes"
              echo "=== Container Logs (tail) ==="
              echo "${LOGS}"
              exit 1
            fi

            if [ $((i % 10)) -eq 0 ]; then
              echo "Still waiting... ($i/180 checks, ~$((i*5)) seconds elapsed)"
            fi
            sleep 5
          done

          echo "=== Boot Summary (last 40 lines) ==="
          docker logs "${CONTAINER_NAME}" --tail 40 2>&1 || true

      - name: Verify headless interface
        run: |
          set -euo pipefail
          echo "Verifying headless interface components..."

          # Must have PTY path
          docker exec "${CONTAINER_NAME}" test -f /var/log/qemu/pty.path || { echo "ERROR: PTY path file not found"; exit 1; }
          PTY_PATH="$(docker exec "${CONTAINER_NAME}" cat /var/log/qemu/pty.path)"
          echo "Guest PTY: ${PTY_PATH}"
          echo "GUEST_PTY=${PTY_PATH}" >> $GITHUB_ENV

          # Ensure console.log exists (host-mounted)
          docker exec "${CONTAINER_NAME}" test -f /var/log/qemu/console.log || { echo "ERROR: console.log missing"; exit 1; }

          # Ensure FIFO exists; if missing, create it and start a bridge to the PTY
          if ! docker exec "${CONTAINER_NAME}" test -p /var/log/qemu/guest.in; then
            echo "guest.in FIFO missing — creating and starting bridge..."
            docker exec "${CONTAINER_NAME}" bash -lc '
              set -euo pipefail
              mkdir -p /var/log/qemu
              # Create FIFO if absent
              [ -p /var/log/qemu/guest.in ] || mkfifo /var/log/qemu/guest.in
              chmod 666 /var/log/qemu/guest.in || true

              PTY="$(cat /var/log/qemu/pty.path)"
              # Kill any stale bridge (best effort)
              pkill -f "cat /var/log/qemu/guest.in" 2>/dev/null || true

              # Start FIFO -> PTY bridge in background, fully detached
              # Use stdbuf to avoid stdio buffering; raw PTY, no echo in QEMU side is assumed
              nohup bash -lc "
                exec </dev/null >/var/log/qemu/guest-bridge.log 2>&1
                set -e
                stdbuf -i0 -o0 -e0 cat /var/log/qemu/guest.in > \"${PTY}\"
              " >/dev/null 2>&1 &
            '
            echo "✓ FIFO created and bridge started"
          else
            echo "✓ guest.in FIFO present"
          fi

          # Quick sanity: show bridge log (may be empty early on)
          docker exec "${CONTAINER_NAME}" bash -lc 'test -f /var/log/qemu/guest-bridge.log && tail -n 5 /var/log/qemu/guest-bridge.log || true'

      - name: Ping FIFO/bridge (prove shell input reaches guest)
        run: |
          set -euo pipefail
          # Send a unique probe line to guest via FIFO and wait for it in console.log
          PROBE="__HOST_PROBE__$(date +%s%N)"
          echo "Sending probe: ${PROBE}"
          docker exec "${CONTAINER_NAME}" bash -lc "printf '%s\n' \"echo ${PROBE}\" > /var/log/qemu/guest.in"

          # Wait up to ~30s for the probe to appear in the console log
          for i in $(seq 1 60); do
            if docker exec "${CONTAINER_NAME}" sh -lc "grep -q \"${PROBE}\" /var/log/qemu/console.log"; then
              echo "✓ Probe detected in console.log"
              exit 0
            fi
            sleep 0.5
          done

          echo "ERROR: Probe not observed in console.log — FIFO/bridge is not functional"
          echo "=== Bridge log (last 50 lines) ==="
          docker exec "${CONTAINER_NAME}" bash -lc 'tail -n 50 /var/log/qemu/guest-bridge.log 2>/dev/null || echo "(no bridge log)"'
          exit 1

      - name: Run sanity suite via scripts/shell.sh (marker-bound)
        run: |
          set -euo pipefail

          # Run the interactive wrapper non-interactively by piping commands.
          # We capture output and enforce that every command ends with "[exit 0]".
          CMDS_FILE="${{ github.workspace }}/sanity_cmds.txt"
          OUT_FILE="${{ github.workspace }}/sanity_output.txt"

          cat > "${CMDS_FILE}" <<'EOF'
          echo "=== System Information Tests ==="
          uname -a
          whoami
          pwd
          sudo apt -y update
          cat /etc/os-release | head -3
          lscpu | head -10
          free -h
          df -h /
          ls -la /workspace
          echo "GitHub Actions Test - $(date)" | tee /workspace/test_output.txt
          cat /workspace/test_output.txt
          echo "OK"
          EOF

          # Provide env so the wrapper knows the mounted paths
          export CONSOLE_LOG="${LOG_DIR}/console.log"
          export GUEST_FIFO="/var/log/qemu/guest.in"
          export STREAM_TIMEOUT_SECONDS="${STREAM_TIMEOUT_SECONDS}"

          # Pipe commands into the wrapper; capture all stdout/err
          set -o pipefail
          cat "${CMDS_FILE}" | scripts/shell.sh "${CONTAINER_NAME}" | tee "${OUT_FILE}"

          # Count commands we expect to run (non-empty, non-comment lines)
          EXPECT=$(grep -vE '^\s*($|#)' "${CMDS_FILE}" | wc -l | awk '{print $1}')
          # Count successful exits in output
          GOT=$(grep -c '^\[exit 0\]$' "${OUT_FILE}" || true)

          echo "Expected successful commands: ${EXPECT}"
          echo "Observed [exit 0] markers:   ${GOT}"

          # It’s normal for the banner/prompt lines not to have exit markers;
          # but every injected command in CMDS_FILE will. Enforce equality.
          if [ "${GOT}" -ne "${EXPECT}" ]; then
            echo "ERROR: Not all commands completed successfully."
            echo "---- Tail of output ----"
            tail -n 120 "${OUT_FILE}" || true
            exit 1
          fi

          echo "✓ Sanity suite completed with all commands [exit 0]"

      - name: Verify test results on host
        run: |
          set -euo pipefail
          echo "=== Verifying Test Results ==="
          if [ -f "${WORK_DIR}/test_output.txt" ]; then
            echo "✓ Workspace file successfully created"
            echo "Contents:"
            cat "${WORK_DIR}/test_output.txt"
          else
            echo "✗ ERROR: Workspace test file not found"
            exit 1
          fi

      - name: Display final console output
        if: always()
        run: |
          echo "=== Final Console Output (last 120 lines) ==="
          docker exec "${CONTAINER_NAME}" tail -n 120 /var/log/qemu/console.log 2>/dev/null || echo "Console log not accessible"

      - name: Logs and diagnostics
        if: always()
        run: |
          echo "=== Container Status ==="
          docker ps -a --filter "name=${CONTAINER_NAME}"

          echo ""
          echo "=== Mounted Workspace ==="
          ls -la "${WORK_DIR}" || echo "Workspace not found"

          echo ""
          echo "=== Mounted Log Directory ==="
          ls -la "${LOG_DIR}" || echo "Log directory not found"

          echo ""
          echo "=== Container Boot Log (last 60 lines) ==="
          docker logs --tail 60 "${CONTAINER_NAME}" 2>&1 || echo "Could not get container logs"

          echo ""
          echo "=== QEMU Boot Log (last 40 lines) ==="
          docker exec "${CONTAINER_NAME}" tail -n 40 /var/log/qemu/qemu.boot.log 2>/dev/null || echo "Boot log not accessible"

      - name: Upload logs and artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: riscv-qemu-logs
          path: |
            ${{ github.workspace }}/var/log/qemu/
            ${{ github.workspace }}/workspace/
            ${{ github.workspace }}/sanity_cmds.txt
            ${{ github.workspace }}/sanity_output.txt
          retention-days: 7

      - name: Cleanup
        if: always()
        run: |
          docker stop "${CONTAINER_NAME}" 2>/dev/null || true
          docker rm "${CONTAINER_NAME}" 2>/dev/null || true
