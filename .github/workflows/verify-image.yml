name: Verify RISC-V Docker Image

on:
  workflow_dispatch:
  push:
    branches: [ main ]

jobs:
  verify:
    runs-on: ubuntu-latest

    steps:
      - name: Pull latest image and show identifiers
        run: |
          set -euo pipefail
          docker pull cloudv10x/riscv-qemu-ubuntu:latest
          echo "IMAGE_ID=$(docker inspect --format='{{.Id}}' cloudv10x/riscv-qemu-ubuntu:latest)" >> $GITHUB_ENV
          echo "REPO_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' cloudv10x/riscv-qemu-ubuntu:latest)" >> $GITHUB_ENV
          echo "Pulled image:"
          echo "  ID: $(docker inspect --format='{{.Id}}' cloudv10x/riscv-qemu-ubuntu:latest)"
          echo "  Digest: $(docker inspect --format='{{index .RepoDigests 0}}' cloudv10x/riscv-qemu-ubuntu:latest)"

      - name: Start container 
        run: |
          set -euo pipefail
          # -d -t gives the entrypoint a TTY so 'socat ... </dev/stdin' can attach safely
          # AUTO_ATTACH=0 is a hint to your script to not steal the console (ignored if unsupported)
          docker run -d -t --name riscv-test --network host \
            -e AUTO_ATTACH=0 \
            cloudv10x/riscv-qemu-ubuntu:latest
          docker ps

      - name: Wait for boot-ready and discover guest serial PTY
        timeout-minutes: 15
        run: |
          set -euo pipefail

          echo "Waiting for container to stay alive and QEMU to start..."
          # Wait for container + qemu pid to appear
          for i in $(seq 1 180); do
            if ! docker ps --format '{{.Names}}' | grep -q '^riscv-test$'; then
              echo "Container exited early. Recent logs:"; docker logs riscv-test || true; exit 1
            fi
            QPID=$(docker exec riscv-test sh -lc 'pgrep -x qemu-system-riscv64 | head -n1' || true)
            if [ -n "${QPID:-}" ]; then
              break
            fi
            sleep 3
          done
          if [ -z "${QPID:-}" ]; then
            echo "ERROR: QEMU process not found."; docker logs riscv-test || true; exit 1
          fi
          echo "QEMU PID: $QPID"

          # Primary: find a /dev/pts/N that QEMU holds open (serial pty)
          PTY=$(docker exec riscv-test sh -lc \
            'ls -l /proc/'"$QPID"'/fd 2>/dev/null | awk "/pts\\/[0-9]+/ {print \$NF}" | tail -n1' || true)
          if [ -n "$PTY" ]; then
            echo "GUEST_PTY=$PTY" | tee -a $GITHUB_ENV
            echo "Found PTY via /proc: $PTY"
            exit 0
          fi

          # Fallback 1: parse from boot log announcement
          PTY=$(docker exec riscv-test sh -lc \
            "awk '/Guest serial PTY: \\/dev\\/pts\\//{print \\$NF}' /var/log/qemu/qemu.boot.log | tail -n1" || true)
          if [ -n "$PTY" ]; then
            echo "GUEST_PTY=$PTY" | tee -a $GITHUB_ENV
            echo "Found PTY via boot log: $PTY"
            exit 0
          fi

          # Fallback 2: query HMP monitor if available
          for sock in /tmp/qemu-monitor.sock /var/run/qemu-monitor.sock /var/run/qemu/monitor.sock; do
            if docker exec riscv-test sh -lc "[ -S $sock ]"; then
              echo "Querying monitor at $sock ..."
              PTY=$(docker exec riscv-test sh -lc \
                "printf 'info chardev\n' | socat - UNIX-CONNECT:$sock | awk '/ttyS0|serial0|chardev/ && /path=/ { for(i=1;i<=NF;i++){ if(\$i ~ /^path=/){ sub(/path=/,\"\"); gsub(/,/,\"\"); print \$i } } }' | tail -n1" || true)
              if [ -n "$PTY" ]; then
                echo "GUEST_PTY=$PTY" | tee -a $GITHUB_ENV
                echo "Found PTY via monitor: $PTY"
                exit 0
              fi
            fi
          done

          echo "ERROR: Could not discover guest serial PTY."
          docker exec riscv-test sh -lc 'tail -n +1 /var/log/qemu/qemu.boot.log || true' || true
          exit 1

      - name: Run basic checks INSIDE the guest via serial PTY
        run: |
          set -euo pipefail
          echo "Using PTY: $GUEST_PTY"

          # Helper: send one line to guest console
          send() { docker exec riscv-test sh -lc "printf '%s\r\n' \"$*\" > $GUEST_PTY"; }

          # Nudge the console (ensures getty has focus)
          send ""
          sleep 2

          send "echo '=== /etc/os-release ===' && cat /etc/os-release"
          send "echo '=== uname -a ===' && uname -a"
          send "echo '=== lscpu ===' && lscpu || true"
          send "echo '=== cpuinfo ===' && sed -n '1,120p' /proc/cpuinfo || true"
          send "echo '=== memory ===' && free -h"
          send "echo '=== disk ===' && df -h"
          send "echo '=== network ===' && ip a && ip route && (resolvectl status | sed -n '1,80p' || true)"
          send "echo '=== apt-get update ===' && sudo apt-get update -y || sudo apt-get update -y"

          # Give console time to flush
          sleep 20

          echo "----- Console tail (guest serial) -----"
          docker exec riscv-test sh -lc "tail -n 500 $GUEST_PTY || true" || true
          echo "----- QEMU boot log tail -----"
          docker exec riscv-test sh -lc "tail -n 300 /var/log/qemu/qemu.boot.log || true" || true

          echo "Image ID: $IMAGE_ID"
          echo "Repo Digest: $REPO_DIGEST"

      - name: Cleanup
        if: always()
        run: |
          docker logs riscv-test || true
          docker rm -f riscv-test || true
