name: Verify RISC-V Docker Image

on:
  workflow_dispatch:
  push:
    branches: [ main ]

jobs:
  verify:
    runs-on: ubuntu-latest

    steps:
      - name: Pull latest image and show identifiers
        run: |
          set -euo pipefail
          docker pull cloudv10x/riscv-qemu-ubuntu:latest
          echo "IMAGE_ID=$(docker inspect --format='{{.Id}}' cloudv10x/riscv-qemu-ubuntu:latest)" >> $GITHUB_ENV
          echo "REPO_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' cloudv10x/riscv-qemu-ubuntu:latest)" >> $GITHUB_ENV
          echo "Pulled image:"
          echo "  ID: $(docker inspect --format='{{.Id}}' cloudv10x/riscv-qemu-ubuntu:latest)"
          echo "  Digest: $(docker inspect --format='{{index .RepoDigests 0}}' cloudv10x/riscv-qemu-ubuntu:latest)"

      - name: Start container 
        run: |
          set -euo pipefail
          # -d -t gives the entrypoint a TTY so 'socat ... </dev/stdin' can attach safely
          # AUTO_ATTACH=0 is a hint to your script to not steal the console (ignored if unsupported)
          docker run -d -t --name riscv-test --network host \
            -e AUTO_ATTACH=0 \
            cloudv10x/riscv-qemu-ubuntu:latest
          docker ps

      - name: Wait for boot-ready and discover guest serial PTY
        timeout-minutes: 15
        run: |
          set -euo pipefail

          # 1) Keep checking container liveness + boot markers
          echo "Waiting for boot markers..."
          for i in $(seq 1 150); do
            # container died?
            if ! docker ps --format '{{.Names}}' | grep -q '^riscv-test$'; then
              echo "Container is not running. Recent logs:"
              docker logs riscv-test || true
              exit 1
            fi
            # saw boot marker?
            if docker exec riscv-test sh -lc \
              "grep -E 'RISC-V Ubuntu image is ready|cloud-init.*finished|Ubuntu .+ ttyS0' /var/log/qemu/qemu.boot.log >/dev/null 2>&1"; then
              echo "Boot marker found."
              break
            fi
            sleep 4
          done

          # 2) Try to read PTY from boot.log (fast path)
          PTY=$(docker exec riscv-test sh -lc "awk '/Guest serial PTY: \\/dev\\/pts\\//{print \$NF}' /var/log/qemu/qemu.boot.log | tail -n1" || true)
          if [ -n "$PTY" ]; then
            echo "GUEST_PTY=$PTY" | tee -a $GITHUB_ENV
            echo "Discovered PTY from log: $PTY"
            exit 0
          fi

          # 3) Fallback: ask the QEMU monitor (HMP) for chardev info
          #    Your entrypoint starts QEMU with: -monitor unix:${MON_SOCK},server,nowait
          #    Try common socket paths if you didn't export MON_SOCK; adjust if yours differs.
          for sock in /tmp/qemu-monitor.sock /var/run/qemu-monitor.sock /var/run/qemu/monitor.sock; do
            if docker exec riscv-test sh -lc "[ -S $sock ]"; then
              echo "Querying monitor at $sock ..."
              PTY=$(docker exec riscv-test sh -lc "printf 'info chardev\\n' | socat - UNIX-CONNECT:$sock | awk '/ttyS0|serial0|chardev/ && /backend/ && /path/ { for(i=1;i<=NF;i++){ if(\$i ~ /^path=/){ sub(/path=/,\"\"); gsub(/,/,\"\"); print \$i } } }' | tail -n1" || true)
              if [ -n "$PTY" ]; then
                echo "GUEST_PTY=$PTY" | tee -a $GITHUB_ENV
                echo "Discovered PTY from monitor: $PTY"
                exit 0
              fi
            fi
          done

          # 4) Last resort: locate the PTY by following QEMU's file descriptors
          PTY=$(docker exec riscv-test sh -lc "pid=\$(pgrep -x qemu-system-riscv64 | head -n1); test -n \"\$pid\" || exit 0; ls -l /proc/\$pid/fd 2>/dev/null | awk '/pts\\/[0-9]+/ {print \$NF}' | tail -n1" || true)
          if [ -n "$PTY" ]; then
            echo "GUEST_PTY=$PTY" | tee -a $GITHUB_ENV
            echo "Discovered PTY from /proc: $PTY"
            exit 0
          fi

          echo 'ERROR: Could not discover guest serial PTY.'
          docker exec riscv-test sh -lc 'tail -n +1 /var/log/qemu/qemu.boot.log || true' || true
          exit 1

      - name: Run basic checks INSIDE the guest via serial PTY
        run: |
          set -euo pipefail
          echo "Using PTY: $GUEST_PTY"

          # Helper to send a command to the guest serial (CRLF to simulate Enter)
          send() { docker exec riscv-test sh -lc "printf '%s\r\n' \"$*\" > $GUEST_PTY"; }

          # If your image autologins 'ubuntu', no login needed. Otherwise, uncomment:
          # send "ubuntu"; send "ubuntu"   # username & password

          send "echo '=== /etc/os-release ===' && cat /etc/os-release"
          send "echo '=== uname -a ===' && uname -a"
          send "echo '=== lscpu ===' && lscpu || true"
          send "echo '=== cpuinfo ===' && sed -n '1,120p' /proc/cpuinfo || true"
          send "echo '=== memory ===' && free -h"
          send "echo '=== disk ===' && df -h"
          send "echo '=== network ===' && ip a && ip route && (resolvectl status | sed -n '1,80p' || true)"
          send "echo '=== apt-get update ===' && sudo apt-get update -y || sudo apt-get update -y"

          # Give guest time to print output
          sleep 15

          echo "----- Console tail (guest serial) -----"
          docker exec riscv-test sh -lc "tail -n 400 $GUEST_PTY || true" || true
          echo "----- QEMU boot log tail -----"
          docker exec riscv-test sh -lc "tail -n 200 /var/log/qemu/qemu.boot.log || true"

          echo "Image ID: $IMAGE_ID"
          echo "Repo Digest: $REPO_DIGEST"

      - name: Cleanup
        if: always()
        run: |
          docker logs riscv-test || true
          docker rm -f riscv-test || true
